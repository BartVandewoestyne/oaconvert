/*
  Copyright 2011 Bart Vandewoestyne, Yves Frederix.

  This file is part of oaconvert.

  oaconvert is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  oaconvert is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with oaconvert.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "KMLState.h"

#include <cassert>
#include <cmath>
#include <string>

#include "Airspace.h"
#include "Circle.h"
#include "Constants.h"
#include "CurvedPolygon.h"

using namespace std;
using namespace Constants;

KMLState* KMLState::_instance = 0;


KMLState::KMLState()
{
}


KMLState* KMLState::getInstance()
{
    if (_instance == 0)
    {
        _instance = new KMLState;
    }
    return _instance;
}


void KMLState::writeHeader(std::ostream &out) const
{
    out << "; Generated by oaconvert (OpenAir to KML Format converter)\n";
    out << "[IMG ID]" << endl;

}


void KMLState::writeFooter(std::ostream &out) const
{
}


void KMLState::write(std::ostream& stream, const Airspace& airspace) const
{
    // See section 4.2.4.2 in
    //   http://cgpsmapper.com/download/cGPSmapper-UsrMan-v02.1.pdf

    // First, draw all things that need to be a POLYGON.  Only
    // Danger and Restricted zones are not POLYGONs.
    if ( !(    airspace.isDanger()
            || airspace.isRestricted()
            || airspace.isFIR()
            || airspace.isMapEdge()
            || airspace.isByNOTAM()) ) {

        stream << "[POLYGON]" << endl;
        stream << "Type=" << getPolygonType(airspace) << endl;
        stream << "Label=";
        if ( airspace.isTMA() ) {
            stream << "TMA:";
        }
        if ( airspace.isCTA() ) {
            stream << "CTA:";
        }
        if ( airspace.isProhibited() ) {
            stream << "Prohibited:";
        }
        if ( airspace.isVectoringArea() ) {
            stream << "Vectoring Area:";
        }
        if ( airspace.isByNOTAM() ) {
            stream << "By NOTAM:";
        }
        if ( (   airspace.isTMA()
              || airspace.isCTA()
              || airspace.isVectoringArea()
              || airspace.isByNOTAM()
              || airspace.isProhibited() ) && (airspace.getFloor() > 0) ) {

            string myName(airspace.getName());
            if (airspace.isByNOTAM()) {
              myName = myName.substr(10);
            }
            if (airspace.hasAGLFloor()) {
                stream << " " << floor(airspace.getFloor()) << " m AGL max";
            } else if (airspace.hasFLFloor()) {
                stream << " " << floor(airspace.getFloor()) << " m (+QNH) max";
            } else {
                stream << " " << floor(airspace.getFloor()) << " m max";
            }
            stream << " (" << myName << ")";

        } else {
          stream << airspace.getName();
        }
        stream << endl;

        // The EndLevel number must not be higher than the highest X from the
        // LevelX records in the KML header.
        stream << "EndLevel=4" << endl;
        write(stream, airspace.getCurvedPolygon());
        stream << "[END]\n" << endl;

    }


    // Now, write out all things that also need to have a POLYLINE.

    stream << "[POLYLINE]" << endl;
    stream << "Type=" << getLineType(airspace) << endl;
    stream << "Label=";
    if ( airspace.isDanger() ) {
        stream << "Danger: ";
    } 
    if ( airspace.isRestricted() ) {
        stream << "Restricted: ";
    } 
    if ( airspace.isByNOTAM() ) {
        stream << "By NOTAM: ";
    }
    string myName(airspace.getName());
    if (airspace.isByNOTAM()) {
      myName = myName.substr(10);
    }
    stream << myName;
    stream << endl;

    // The EndLevel number must not be higher than the highest X from the
    // LevelX records in the KML header.
    stream << "EndLevel=4" << endl;
    write(stream, airspace.getCurvedPolygon());
    stream << "[END]\n" << endl;

}


void KMLState::write(std::ostream& stream, const CurvedPolygon& p) const
{
    std::vector<Coordinate> coords;
    p.discretize( coords, RESOLUTION );
    write( stream, coords );
}


void KMLState::write(std::ostream& out, const std::vector<Coordinate>& coords) const
{
    if (coords.size() > 0)
    {
        out << "Data0=";
        for (size_t i = 0; i < coords.size()-1; ++i)
        {
            write(out, coords[i]);
            out << ",";
        }
        write(out, coords.back());
        out << endl;
    }
}


void KMLState::write(ostream& out, const Coordinate& c) const
{
    out << "(" << c.getLatitude().getAngle() << "," << c.getLongitude().getAngle() << ")";
}


/*
 * Return the KML File [POLYGON] type for the given airspace class.
 * For the listing of the different possible types, see cgpsmapper manual,
 * table 9.3.3 page 89.
 *
 * Note: The Python script at
 *
 *   http://www.penguin.cz/~ondrap/paragliding.php
 *
 * sets the polygon type according to the following rules:
 *
 *      if AH - AL < 500 and AL < 2000:
 *          type = '78'
 *      elif AL == 0:
 *          type = '0x08'
 *      elif AL < 500:
 *          type = '0x1e'
 *      elif AL < 1000:
 *          type = '0x3c'
 *      elif AL < 1900:
 *          type = '0x18'
 *      else:
 *          type = '0x53'
 *
 */
std::string KMLState::getPolygonType(const Airspace& space) const
{
    if (space.isCTR()) {
        return string("0x61");
    } else if (space.isCTA()) {
        return string("0x62");
    } else if ( space.isFloating() && !space.isLowFlyingAreaGolf() ) {
        return string("0x63");
    } else if (space.isLowFlyingAreaGolf()) {
        return string("0x64");
    } else if (space.isRestricted()) {
        return string("0x65");
    } else if (space.isProhibited()) {
        return string("0x66");
    } else if (space.isDanger()) {
        return string("0x67");
    } else {
        return string("0x69");
    }
}

std::string KMLState::getLineType(const Airspace& space) const
{
  if (space.isFIR()) {
      return string("0x01");
  } else if (space.isDanger()) {
      return string("0x02");
  } else if (space.isRestricted()) {
      return string("0x03");
  } else if (space.isByNOTAM()) {
      return string("0x04");
  } else if (space.isMapEdge()) {
      return string("0x05");
  } else {
      return string("0x06");
  }
}
