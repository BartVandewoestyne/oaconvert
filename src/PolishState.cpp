/*
  Copyright 2011 Bart Vandewoestyne, Yves Frederix.

  This file is part of oaconvert.

  oaconvert is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  oaconvert is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with oaconvert.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PolishState.h"

#include <cassert>
#include <cmath>
#include <string>
#include <sstream>

#include "Airspace.h"
#include "Circle.h"
#include "Constants.h"
#include "CurvedPolygon.h"

using namespace std;
using namespace Constants;

// Note: if you change a value here, you *must* also
//       change the value in every TYP-file where it occurs!
const string PolishState::LINETYPE_ATZ              = "0x06";
const string PolishState::LINETYPE_BY_AUP           = "0x04";
const string PolishState::LINETYPE_BY_NOTAM         = "0x04";
const string PolishState::LINETYPE_CTA              = "0x11";
const string PolishState::LINETYPE_CTR              = "0x06";
const string PolishState::LINETYPE_DANGER           = "0x08";
const string PolishState::LINETYPE_DEFAULT          = "0x07";
const string PolishState::LINETYPE_FIR              = "0x01";
const string PolishState::LINETYPE_LOW_FLYING_AREA  = "0x03";
const string PolishState::LINETYPE_LOW_FLYING_ROUTE = "0x10";
const string PolishState::LINETYPE_PROHIBITED       = "0x08";
const string PolishState::LINETYPE_RESTRICTED       = "0x08";
const string PolishState::LINETYPE_SRZ              = "0x06";
const string PolishState::LINETYPE_TMA              = "0x11";
const string PolishState::LINETYPE_TMZ              = "0x06";
const string PolishState::LINETYPE_AIRWAY           = "0x06";

const string PolishState::POLYGONTYPE_AIRWAY                = "0x60";
const string PolishState::POLYGONTYPE_ATZ                   = "0x61";
const string PolishState::POLYGONTYPE_ATZ_CTR               = "0x66";
const string PolishState::POLYGONTYPE_BY_AUP                = "0x60";
const string PolishState::POLYGONTYPE_BY_NOTAM              = "0x60";
const string PolishState::POLYGONTYPE_CTA                   = "0x62";
const string PolishState::POLYGONTYPE_TMA                   = "0x64";
const string PolishState::POLYGONTYPE_CTR_ABOVE_GROUND      = "0x63";
const string PolishState::POLYGONTYPE_CTR_FROM_GROUND       = "0x61";
const string PolishState::POLYGONTYPE_DANGER                = "0x61";
const string PolishState::POLYGONTYPE_DEFAULT               = "0x69";
const string PolishState::POLYGONTYPE_LFA                   = "0x68";
const string PolishState::POLYGONTYPE_LFAG                  = "0x60";
const string PolishState::POLYGONTYPE_NON_LFAG_ABOVE_GROUND = "0x60";
const string PolishState::POLYGONTYPE_PROHIBITED            = "0x66";
const string PolishState::POLYGONTYPE_RESTRICTED            = "0x61";
const string PolishState::POLYGONTYPE_SRZ                   = "0x63";
const string PolishState::POLYGONTYPE_TMZ                   = "0x60";


PolishState* PolishState::_instance = 0;


PolishState::PolishState()
{
}


PolishState* PolishState::getInstance()
{
    if (_instance == 0)
    {
        _instance = new PolishState;
    }
    return _instance;
}


void PolishState::writeHeader(std::ostream &out) const
{
    out << "; Generated by oaconvert (OpenAir to Polish Format converter)\n";

    // Section identifier (mandatory).
    out << "[IMG ID]" << endl;

    // Unique identifier (up to 8 decimal digits) for the map (mandatory).  May
    // be only written in a decimal format.  I have found the following values:
    //   cgpsmapper manual: 11000204
    //   oa2gm:             42200100
    //   gscripts:          42099999
    // Setting this one to my birthday :-)
    out << "ID=19780321" << endl;

    // Map name to be displayed in the GPS receiver's Map Info menu (mandatory).
    out << "Name=My Very Special Map" << endl;

    // Instead of single byte coding, use full-byte (8-bit) character coding
    // with the specified codepage (depending on the GPS firmware) (optional).
    // 
    // According to page chapter 6 'National characters - indexing' in the
    // cGPSmapper usermanual, the only codepage fully supported by all (or most
    // of) receivers is 1252 (Western European).  Also, only with this codepage
    // it is possible to use lowercase characters.  No other codepage is
    // capable to show lowercase characters.  When using any other codepage
    // than 1252, all labels in the input MP file must be uppercase, or they
    // will not be correctly presented in the receiver.
    out << "Codepage=1252" << endl;

    // When a transparent map is displayed on a GPS unit, features
    // in the unit's basemap will also be visible.  If your map is not
    // transparent, it will obscure the basemap when visible.
    // Semi-transparent map is created in a way a usual map is
    // created, but no background object is created.  Full transparent
    // map is created in a way that no background object is created
    // and information in IMG is stored that map is transparent.
    // -> In some cases - to have a nice overlapping map it is
    // necessary to use semi-transparency instead of full-transparency.
    //
    // Note Bart: BaseCamp software has a problem with S, so trying N.
    out << "Transparent=Y" << endl;

    // Subfamily identifier used for locked IMG files only â€“ value
    // between 1 and 255. Each subfamily can be unlocked with
    // universal unlock code or separately with individual unlock
    // code. (Default = 1)
    out << "ProductCode=1" << endl;

    // Only index objects if POI index info is explicitly provided.  With
    // 'indexing', we mean 'make searcheable by the Find function in the GPS'.
    // We follow the default value  of 'N' here.
    out << "POIIndex=N" << endl;

    // Maximum allowed region size.  A higher value increases the allowable
    // region size, but may decrease the map performance; a lower value may
    // increase the map size.
    // I have found the following values:
    // cgpsmapper manual:
    //   topo maps: 1000-2000
    //   city (dense streets): 2000-5000
    //   countryside: 6000-10000
    // oa2gm: 1311
    // gscripts: 6000
    out << "TreSize=1311" << endl;

    // Maximal number of elements in one region (mandatory).
    // Can be any value between ~50 and 1024 (values less than 50 don't make
    // sense).  Recent experiments show that this parameter does not impact
    // map performance and can be set to maximum allowed value: 1024.
    // I have found the following values:
    // cgpsmapper suggested value: 1024
    // oa2gm: none specified
    // gscripts: 1024
    out << "RgnLimit=1024" << endl;

    // Kind of pre-processing.  We're setting it to the default here...
    // cgpsmapper default: F
    // oa2gm:              F
    // gscripts:           F
    out << "PreProcess=F" << endl;


    // Level and Zoom level stuff... this is tricky and we need to find good
    // settings here!
    //
    // Some explanatory examples:
    //
    // 'Levels=': Number of map zoom levels (layers) in the map (mandatory, at least 2,
    //            not more than 10, numbered starting at 0).
    //
    // 'Level0=24': Map zoom level 0 corresponds to hardware zoom level 24 ('Up to 120m')
    //              This means that map objects and coordinates defined as map level 0, will
    //              be used at hardware zoom levels 24 and above.  So they will be visible
    //              if the scale is 120m or more detailed.
    //              The last level is a special one that dictates when our map replaces the
    //              base map.  It means the following: from hardware level
    //              14 ('80km to 120 km') or higher, we will see our map.  At hardware
    //              zoom levels 13 and below, we will see the base map.
    //              We are not allowed to define map objects and coordinates at this level.
    // 'ZoomX=XX': ??
    //
    // Note 1: the last layer must always be empty, e.g. Levels=3
    //         means that only two layers are available for map objects.
    // Note 2: GPS unit map detail must be set to 'Normal'!!!!!
    //         See section 4.4 (on page 40) of cgpsmapper manual (mandatory).
    // Note 3: Hardware Zoom Level 12 represents the most ''zoomed out'' setting for
    //         current Garmin devices, so it makes no sense to go lower.

    // This is what oa2gm and gscripts use, but it didn't work with GPSMapEdit 1.0.70.0.
    //out << "Levels=5\n";
    //out << "Level0=21\n";
    //out << "Level1=19\n";
    //out << "Level2=17\n";
    //out << "Level3=15\n";
    //out << "Level4=14\n";
    //out << "Zoom0=0\n";
    //out << "Zoom1=1\n";
    //out << "Zoom2=2\n";
    //out << "Zoom3=3\n";
    //out << "Zoom4=4\n";

    // This is from http://vjet.f2s.com/gmap/cgpsmapper.html
    // With these, my [POLYLINE]s are visible on my 60CSX if I zoom to 3km or below.
    //out << "Levels=5\n";
    //out << "Level0=24\n";
    //out << "Level1=22\n";
    //out << "Level2=20\n";
    //out << "Level3=19\n";
    //out << "Level4=18\n";
    //out << "Zoom0=0\n";
    //out << "Zoom1=1\n";
    //out << "Zoom2=2\n";
    //out << "Zoom3=3\n";
    //out << "Zoom4=4\n";

    // This is my attempt, trying to get it right for the 60CSX.
    // Order 24/22/20/18/16 -> visible when zoomed in 8 km or finer.
    // Order 24/21/18/15/12 -> visible when zoomed in 50km or finer.
    out << "Levels=5\n";
    out << "Level0=24\n";
    out << "Level1=21\n";
    out << "Level2=18\n";
    out << "Level3=15\n";
    out << "Level4=12\n";
    out << "Zoom0=0\n";
    out << "Zoom1=1\n";
    out << "Zoom2=2\n";
    out << "Zoom3=3\n";
    out << "Zoom4=4\n";

    // Below is what GPSMapEdit 1.0.69.1 outputs, and it seems to work in
    // GPSMapEdit...  Note that this might not work as fluently
    // on actual GPS units like the Garmin 60CSX.
    //out << "Levels=2\n";
    //out << "Level0=24\n";
    //out << "Level1=14\n";
    //out << "Zoom0=0\n";
    //out << "Zoom1=1\n";

    // Section terminator (mandatory)
    out << "[END-IMG ID]\n" << endl;
}


void PolishState::writeFooter( std::ostream& ) const
{
    // Polish files have no footer.
}


void PolishState::write(std::ostream& stream, const Airspace& airspace) const
{
    // See section 4.2.4.2 in
    //   http://cgpsmapper.com/download/cGPSmapper-UsrMan-v02.1.pdf

    if (needsPolygon(airspace)) {

        stream << "[POLYGON]" << endl;
        stream << "Type=" << getPolygonType(airspace) << endl;
        stream << "Label=" << getPolishLabel(airspace) << endl;

        // The EndLevel number must not be higher than the highest X from the
        // LevelX records in the Polish header.
        stream << "EndLevel=4" << endl;
        write(stream, airspace.getCurvedPolygon());
        stream << "[END]\n" << endl;

    }

    if (needsPolyline(airspace)) {

      stream << "[POLYLINE]" << endl;
      stream << "Type=" << getLineType(airspace) << endl;
      stream << "Label=" << getPolishLabel(airspace) << endl;

      // The EndLevel number must not be higher than the highest X from the
      // LevelX records in the Polish header.
      stream << "EndLevel=4" << endl;
      write(stream, airspace.getCurvedPolygon());
      stream << "[END]\n" << endl;

    }

}


void PolishState::write(std::ostream& stream, const CurvedPolygon& p) const
{
    std::vector<Coordinate> coords;
    p.discretize( coords, RESOLUTION );
    write( stream, coords );
}


void PolishState::write(std::ostream& out, const std::vector<Coordinate>& coords) const
{
    if (coords.size() > 0)
    {
        out << "Data0=";
        for (size_t i = 0; i < coords.size()-1; ++i)
        {
            write(out, coords[i]);
            out << ",";
        }
        write(out, coords.back());
        out << endl;
    }
}


void PolishState::write(ostream& out, const Coordinate& c) const
{
    out << "(" << c.getLatitude().getAngle() << "," << c.getLongitude().getAngle() << ")";
}


/*
 * Return the Polish File [POLYGON] type for the given airspace class.
 * For the listing of the different possible types, see cgpsmapper manual,
 * table 9.3.3 page 89.
 *
 * Note: The Python script at
 *
 *   http://www.penguin.cz/~ondrap/paragliding.php
 *
 * sets the polygon type according to the following rules:
 *
 *      if AH - AL < 500 and AL < 2000:
 *          type = '78'
 *      elif AL == 0:
 *          type = '0x08'
 *      elif AL < 500:
 *          type = '0x1e'
 *      elif AL < 1000:
 *          type = '0x3c'
 *      elif AL < 1900:
 *          type = '0x18'
 *      else:
 *          type = '0x53'
 *
 */
std::string PolishState::getPolygonType(const Airspace& space) const
{
  if (space.isCTR()) {
    if (space.getFloor() > 0) {
      return POLYGONTYPE_CTR_ABOVE_GROUND;
    } else {
      return POLYGONTYPE_CTR_FROM_GROUND;
    }
  } else if (space.isATZ()) {
    if (space.getClass() == "CTR") {
      return POLYGONTYPE_ATZ_CTR;
    } else {
      return POLYGONTYPE_ATZ;
    }
  } else if (space.isLowFlyingArea()) {
    return POLYGONTYPE_LFA;
  } else if (space.isCTA()) {
    return POLYGONTYPE_CTA;
  } else if (space.isTMA()) {
    return POLYGONTYPE_TMA;
  } else if (space.isByNOTAM()) {
    return POLYGONTYPE_BY_NOTAM;
  } else if (space.isByAUP()) {
    return POLYGONTYPE_BY_AUP;
  } else if (space.isSRZ()) {
    return POLYGONTYPE_SRZ;
  } else if (space.isTMZ()) {
    return POLYGONTYPE_TMZ;
  } else if (space.isAirway()) {
    return POLYGONTYPE_AIRWAY;
  } else if (space.isRestricted()) {
    return POLYGONTYPE_RESTRICTED;
  } else if (space.isProhibited()) {
    return POLYGONTYPE_PROHIBITED;
  } else if (space.isDanger()) {
    return POLYGONTYPE_DANGER;
  } else if ( space.isFloating() && !space.isLowFlyingAreaGolf() ) {
    return POLYGONTYPE_NON_LFAG_ABOVE_GROUND;
  } else if (space.isLowFlyingAreaGolf()) {
    return POLYGONTYPE_LFAG;
 // } else if (space.isRestricted()) {
 //   return POLYGONTYPE_RESTRICTED;
 // } else if (space.isProhibited()) {
 //   return POLYGONTYPE_PROHIBITED;
 // } else if (space.isDanger()) {
 //   return POLYGONTYPE_DANGER;
  } else {
    return POLYGONTYPE_DEFAULT;
  }
}


std::string PolishState::getLineType(const Airspace& space) const
{
  if (space.isFIR()) {
      return LINETYPE_FIR;
  } else if (space.isByNOTAM()) {
      return LINETYPE_BY_NOTAM;
  } else if (space.isByAUP()) {
      return LINETYPE_BY_AUP;
  } else if (space.isDanger()) {
      return LINETYPE_DANGER; 
  } else if (space.isProhibited()) {
      return LINETYPE_PROHIBITED; 
  } else if (space.isRestricted()) {
      return LINETYPE_RESTRICTED;
  } else if (space.isCTA()) {
      return LINETYPE_CTA;
  } else if (space.isTMA()) {
      return LINETYPE_TMA;  	  
  } else if (space.isCTR()) {
      return LINETYPE_CTR;
  } else if (space.isATZ()) {
      return LINETYPE_ATZ;
  } else if (space.isTMZ()) {
      return LINETYPE_TMZ;
  } else if (space.isAirway()) {
      return LINETYPE_AIRWAY;
  } else if (space.isSRZ()) {
      return LINETYPE_SRZ;
  } else if (space.isLowFlyingRoute()) {
      return LINETYPE_LOW_FLYING_ROUTE;
  } else if (space.isLowFlyingArea()) {
      return LINETYPE_LOW_FLYING_AREA;
  } else {
      return LINETYPE_DEFAULT;
  }
}



/**
 * Return a label for this airspace for a 2D map representation.
 */
string PolishState::getPolishLabel(const Airspace& airspace) const
{
    stringstream pLabel;

    //if ( airspace.isTMA() ) {
    //    pLabel << "TMA:";
    //}
    //if ( airspace.isCTA() ) {
    //    pLabel << "CTA:";
    //}
    if ( airspace.isProhibited() ) {
        pLabel << "Prohibited:";
    }
    //if ( airspace.isVectoringArea() ) {
    //    pLabel << "Vectoring Area:";
    //}
 //   if ( airspace.isByNOTAM() ) {
 //       pLabel << "By NOTAM:";
 //   }
 //   if ( airspace.isByAUP() ) {
 //       pLabel << "By AUP:";
 //   }

    if ( needsAltitudeInLabel(airspace) ) {

        string myName(airspace.getName());
//        if (airspace.isByNOTAM()) {
//          myName = myName.substr(10); // TODO: remove this hardcoded value!
//        }
//        if (airspace.isByAUP()) {
//          myName = myName.substr(8); // TODO: remove this hardcoded value!
//        }

        if (airspace.hasAGLFloor()) {
            pLabel << " " << floor(airspace.getFloor()) << "m";
  
        } else if (airspace.hasFLFloor()) {
            pLabel << " " << floor(airspace.getFloor()) << "m FL";
        } else {
            pLabel << " " << floor(airspace.getFloor()) << "m";
        }
		if (airspace.isLowFlyingArea()) {
            pLabel << "-" << floor(airspace.getCeiling()) << "m";
		}
		if (airspace.isLowFlyingRoute()) {
            pLabel << "-" << floor(airspace.getCeiling()) << "m";
		}
		pLabel << " (" << myName << ")";

    } else {
      pLabel << airspace.getName();
    }

    return pLabel.str();

}


/**
 * Return true if this airspace needs a polygon in its Polish file
 * representation.
 */
bool PolishState::needsPolygon(const Airspace& airspace) const
{
  return (   airspace.isATZ()
          || airspace.isCTA()
          || airspace.isCTR()
          || airspace.isDanger()
          || airspace.isLowFlyingArea()
          || airspace.isLowFlyingAreaGolf()
          || airspace.isProhibited()
          || airspace.isRestricted()
          || airspace.isTMA()
          || airspace.isSRZ()
          || airspace.isTMZ()
          || airspace.isAirway() );
}


/**
 * Return true if this airspace needs a polyline in its Polish file
 * representation.
 */
bool PolishState::needsPolyline(const Airspace& airspace) const
{
  return (   airspace.isFIR()
          || airspace.isLowFlyingRoute()
          || airspace.isByNOTAM()
          || airspace.isByAUP()
		  ||  airspace.isATZ()
//         || airspace.isCTA()
          || airspace.isCTR()
          || airspace.isDanger()
          || airspace.isLowFlyingArea()
          || airspace.isLowFlyingAreaGolf()
          || airspace.isProhibited()
          || airspace.isRestricted()
          || airspace.isSRZ()
          || airspace.isAirway()
          || airspace.isTMZ() );
}



/**
 * Return true if this airspace needs an altitude specification in
 * its Polish label.
 */
bool PolishState::needsAltitudeInLabel(const Airspace& airspace) const
{
  return (   airspace.isTMA()
          || airspace.isCTA()
          || airspace.isCTR()
          || airspace.isVectoringArea()
          || airspace.isByNOTAM()
          || airspace.isByAUP()
          || airspace.isTMZ()
		  || airspace.isSRZ()
          || airspace.isAirway()
		  || airspace.isLowFlyingArea()
		  || airspace.isLowFlyingRoute()
          || airspace.isProhibited() ) && (airspace.getFloor() > 0);
}
